// Determines if the current time is within the quiet hours.
function isQuietTime() {
  const now = new Date();
  const minutes = now.getHours() * 60 + now.getMinutes();
  const month = now.getMonth(); // 0 = January, ... 11 = December
  const isSummer = month >= 3 && month <= 8; // April (3) to September (8)
  let middayQuiet = false;
  let nightQuiet = false;

  // Consistent logic: Assuming quiet hours are inclusive of the end time
  // e.g., "until 17:30" means 17:30 is still quiet.
  if (isSummer) {
    // Summer quiet: 15:00–17:30 (900-1050 min) & 23:00–07:00 (1380-420 min)
    middayQuiet = (minutes >= 900 && minutes <= 1050);
    nightQuiet = (minutes >= 1380 || minutes < 420); // 07:00 is 420 min. <420 means up to 06:59.
  } else {
    // Winter quiet: 15:30–17:30 (930-1050 min) & 22:00–07:30 (1320-450 min)
    middayQuiet = (minutes >= 930 && minutes <= 1050);
    nightQuiet = (minutes >= 1320 || minutes < 450); // 07:30 is 450 min. <450 means up to 07:29.
  }
  return middayQuiet || nightQuiet;
}

// Generates ImageData for a circular icon of the specified size and color.
function getIconData(color, size) {
  try {
    const canvas = new OffscreenCanvas(size, size);
    const ctx = canvas.getContext('2d');
    if (!ctx) {
      console.error(`Failed to get 2D context for OffscreenCanvas of size ${size}`);
      return null;
    }
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
    ctx.fill();
    return ctx.getImageData(0, 0, size, size);
  } catch (error) {
    console.error(`Error in getIconData for color ${color}, size ${size}:`, error);
    return null;
  }
}

// Updates the extension icon based on the current time.
function updateIcon() {
  try {
    const quiet = isQuietTime();
    const color = quiet ? 'red' : 'green'; // Red for quiet, Green for non-quiet

    const iconSizes = [16, 32, 48, 128];
    const imageData = {};
    let generatedCount = 0;

    for (const size of iconSizes) {
      const data = getIconData(color, size);
      if (data) {
        imageData[String(size)] = data;
        generatedCount++;
      }
    }

    if (generatedCount === iconSizes.length) {
      chrome.action.setIcon({ imageData: imageData })
        .catch(e => console.error("Error setting icon with all image data:", e));
    } else if (generatedCount > 0) {
      console.warn("Setting icon with partially generated image data due to some errors.");
      chrome.action.setIcon({ imageData: imageData })
        .catch(e => console.error("Error setting icon with partial image data:", e));
    } else {
      console.error("Completely failed to generate dynamic icons. Attempting to use static fallback icons.");
      // Fallback to static icons if dynamic generation fails for all sizes.
      // Ensure you have 'red-*.png' and 'green-*.png' in your 'icons' folder.
      // These were generated by your icons.html.
      const basePath = quiet ? "icons/red-" : "icons/green-";
      chrome.action.setIcon({
        path: {
          "16": `${basePath}16.png`,
          "32": `${basePath}32.png`,
          "48": `${basePath}48.png`,
          "128": `${basePath}128.png`
        }
      }).catch(e => console.error("Error setting fallback static icon:", e));
    }
  } catch (error) {
    console.error('Error in updateIcon function itself:', error);
  }
}

// Manage the alarm for periodic icon updates.
// This function ensures the alarm is created if it doesn't exist.
async function setupAlarm() {
  try {
    const alarm = await chrome.alarms.get('updateIcon');
    if (!alarm) {
      chrome.alarms.create('updateIcon', { periodInMinutes: 1 });
      console.log("Silence Hero: updateIcon alarm created.");
    } else {
      console.log("Silence Hero: updateIcon alarm already exists.");
    }
  } catch (error) {
    console.error("Silence Hero: Error setting up alarm:", error);
  }
}

chrome.alarms.onAlarm.addListener((alarm) => {
  if (alarm.name === 'updateIcon') {
    updateIcon();
  }
});

// Listener for extension startup or installation
chrome.runtime.onStartup.addListener(() => {
  console.log("Silence Hero: Extension started up.");
  setupAlarm(); // Ensure alarm is set on browser startup
  updateIcon(); // Update icon immediately
});

chrome.runtime.onInstalled.addListener((details) => {
  console.log("Silence Hero: Extension installed or updated.", details);
  setupAlarm(); // Ensure alarm is set on install/update
  updateIcon(); // Update icon immediately
});

// Initial setup when the service worker first loads (e.g., after an update or browser start if not covered by onStartup)
setupAlarm();
updateIcon();